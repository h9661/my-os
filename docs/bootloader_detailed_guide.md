# 부트로더 상세 분석 가이드

## 📋 목차
1. [부트로더 개요](#부트로더-개요)
2. [메모리 레이아웃](#메모리-레이아웃)
3. [실행 단계별 분석](#실행-단계별-분석)
4. [GDT 구조 상세](#gdt-구조-상세)
5. [디스크 로딩 과정](#디스크-로딩-과정)
6. [16비트 → 32비트 전환 과정](#16비트--32비트-전환-과정)

## 부트로더 개요

부트로더는 컴퓨터가 켜질 때 가장 먼저 실행되는 프로그램으로, 운영체제 커널을 메모리에 로드하고 실행하는 역할을 합니다.

### 주요 역할
- ✅ 하드웨어 초기화 (세그먼트, 스택 설정)
- ✅ 커널을 디스크에서 메모리로 로드
- ✅ 16비트 실제 모드에서 32비트 보호 모드로 전환
- ✅ 커널에게 제어권 이양

## 메모리 레이아웃

```
0x00000000 ┌─────────────────┐
           │   인터럽트 벡터   │ ← BIOS 인터럽트 테이블
0x00000400 ├─────────────────┤
           │   BIOS 데이터     │
0x00007C00 ├─────────────────┤
           │   부트로더       │ ← BIOS가 부트섹터를 로드하는 위치
0x00007E00 ├─────────────────┤ ← 부트로더 끝 (512바이트)
           │   사용 가능      │
0x00001000 ├─────────────────┤
           │   커널          │ ← 커널이 로드되는 위치 (4KB)
0x00009000 ├─────────────────┤
           │   스택          │ ← 스택 포인터 초기 위치 (36KB)
0x00090000 ├─────────────────┤
           │   32비트 스택    │ ← 보호 모드에서 사용할 스택 (576KB)
0x000A0000 ├─────────────────┤
           │   VGA 메모리     │ ← 비디오 메모리 (640KB~)
           └─────────────────┘
```

## 실행 단계별 분석

### 1️⃣ BIOS 부팅 과정
```
전원 켜짐 → BIOS 실행 → 부트 디바이스 검색 → 부트섹터(MBR) 로드 → 0x7C00에서 실행
```

### 2️⃣ 16비트 실제 모드 초기화
- **세그먼트 레지스터 초기화**: DS, ES를 0으로 설정
- **스택 설정**: BP=0x9000, SP=0x9000으로 설정
- **부트 드라이브 저장**: BIOS가 DL에 전달한 드라이브 번호 보존

### 3️⃣ 커널 로딩
- **디스크 읽기**: BIOS INT 0x13을 사용하여 30개 섹터를 0x1000 주소에 로드
- **에러 처리**: 디스크 읽기 실패 시 에러 메시지 출력 후 정지

### 4️⃣ 32비트 보호 모드 전환
- **인터럽트 비활성화**: CLI 명령으로 모드 전환 중 인터럽트 방지
- **GDT 로드**: LGDT 명령으로 Global Descriptor Table 설정
- **CR0 레지스터 수정**: PE 비트 설정으로 보호 모드 활성화
- **Far Jump**: 파이프라인 플러시 및 CS 레지스터 업데이트

### 5️⃣ 32비트 모드 초기화
- **세그먼트 레지스터 업데이트**: 모든 세그먼트를 GDT의 셀렉터로 설정
- **새로운 스택 설정**: 더 큰 메모리 공간의 스택 사용
- **화면 클리어**: VGA 메모리 직접 조작으로 화면 지우기

### 6️⃣ 커널 실행
- **최종 메시지 출력**: 커널 점프 직전 알림
- **디버그 표시**: 화면 좌상단에 "BRBR" 표시
- **커널 점프**: 0x1000 주소의 커널로 제어권 이양

## GDT 구조 상세

### GDT 엔트리 포맷 (8바이트)
```
   7         6         5         4         3         2         1         0
┌─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ Base    │ Flags   │ Limit   │ Access  │ Base    │ Base    │ Limit   │ Limit   │
│ 31-24   │ + Limit │ 19-16   │ Byte    │ 23-16   │ 15-0    │ 15-0    │         │
│         │ 23-20   │         │         │         │         │         │         │
└─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘
```

### Access Byte 구조
```
Bit 7: Present (P) - 세그먼트가 메모리에 존재하는지
Bit 6-5: Descriptor Privilege Level (DPL) - 권한 레벨 (00=커널, 11=사용자)
Bit 4: Descriptor Type (S) - 0=시스템, 1=코드/데이터
Bit 3-0: Type - 세그먼트 타입
  코드: 1010 (실행/읽기 가능)
  데이터: 0010 (읽기/쓰기 가능)
```

### Flags 구조
```
Bit 3: Granularity (G) - 0=바이트 단위, 1=4KB 단위
Bit 2: Size (D/B) - 0=16비트, 1=32비트
Bit 1: Long mode (L) - 0=32비트, 1=64비트
Bit 0: Available (AVL) - 운영체제가 사용 가능
```

## 디스크 로딩 과정

### BIOS INT 0x13 파라미터
```
AH = 0x02 (읽기 기능)
AL = 읽을 섹터 수
CH = 실린더 번호
CL = 시작 섹터 번호
DH = 헤드 번호
DL = 드라이브 번호
ES:BX = 목표 메모리 주소
```

### CHS (Cylinder-Head-Sector) 주소 지정
```
┌─────────────┬───────────────┬─────────────────┐
│   실린더     │     헤드      │      섹터       │
│ (트랙 번호)   │  (면 번호)     │  (섹터 번호)     │
└─────────────┴───────────────┴─────────────────┘
```

## 16비트 → 32비트 전환 과정

### 1. 전환 전 준비
```assembly
cli                    ; 인터럽트 비활성화
lgdt [gdt_descriptor]  ; GDT 로드
```

### 2. CR0 레지스터 수정
```assembly
mov eax, cr0           ; CR0 읽기
or al, 1               ; PE 비트 설정
mov cr0, eax           ; CR0 쓰기 → 보호 모드 활성화
```

### 3. Far Jump로 파이프라인 플러시
```assembly
jmp CODE_SEG:init_pm   ; CS 레지스터 업데이트 + 파이프라인 클리어
```

### 4. 세그먼트 레지스터 업데이트
```assembly
mov ax, DATA_SEG       ; 데이터 세그먼트 셀렉터
mov ds, ax             ; 모든 세그먼트 레지스터를
mov ss, ax             ; GDT의 셀렉터로 업데이트
mov es, ax
mov fs, ax
mov gs, ax
```

## 중요한 개념들

### 🔑 세그먼트 레지스터
- **CS**: 코드 세그먼트 (실행 중인 명령어가 있는 메모리 영역)
- **DS**: 데이터 세그먼트 (일반 데이터가 있는 메모리 영역)
- **SS**: 스택 세그먼트 (스택이 있는 메모리 영역)
- **ES**: 확장 세그먼트 (문자열 연산 등에 사용)

### 🔑 스택의 특성
- **성장 방향**: 높은 주소 → 낮은 주소
- **PUSH**: SP 감소 후 데이터 저장
- **POP**: 데이터 읽기 후 SP 증가

### 🔑 VGA 텍스트 모드
- **주소**: 0xB8000 ~ 0xB8FA0 (80×25 = 2000 문자)
- **포맷**: 각 문자는 2바이트 (문자 + 속성)
- **속성**: 상위 4비트(배경색) + 하위 4비트(글자색)

### 🔑 부트 시그니처
- **위치**: 부트섹터의 마지막 2바이트 (510, 511번째)
- **값**: 0x55AA (리틀 엔디안으로 0xAA55)
- **목적**: BIOS가 유효한 부트섹터인지 확인

## 디버깅 팁

### 1. QEMU에서 실행 시 확인사항
```bash
qemu-system-i386 -drive format=raw,file=hard-disk.img
```

### 2. 일반적인 문제들
- **무한 재부팅**: 부트 시그니처(0xAA55) 누락
- **커널 로드 실패**: 디스크 읽기 에러 또는 잘못된 섹터 수
- **보호 모드 전환 실패**: GDT 설정 오류 또는 잘못된 셀렉터

### 3. 유용한 디버깅 출력
- 각 단계별 메시지 출력으로 진행 상황 확인
- 레지스터 값을 16진수로 출력하여 상태 확인
- VGA 메모리에 직접 문자 출력으로 보호 모드 동작 확인
