; ============================================================================
; 커널 진입점 (Kernel Entry Point) - 32비트 보호 모드
; ============================================================================
; 역할: 1) 부트로더에서 커널로 제어권 이양받기 2) 커널 환경 초기화 3) C 커널 호출
; 부트로더가 32비트 보호 모드로 전환한 후 이 코드로 점프하여 커널이 시작됨

[BITS 32]              ; 32비트 보호 모드 명령어로 컴파일 지시
                       ; 이미 부트로더에서 보호 모드로 전환되었으므로 32비트 명령어 사용
[EXTERN kernel_main]   ; C 함수 kernel_main을 외부 참조로 선언
                       ; 링커가 kernel.c에서 정의된 kernel_main 함수와 연결해줌
                       ; EXTERN: 다른 오브젝트 파일에 정의된 심볼을 참조

; === 전역 심볼 선언 ===
; 링커가 이 주소를 찾을 수 있도록 전역 심볼로 선언
global _start          ; _start 심볼을 전역으로 선언 (링커 스크립트에서 참조)
                       ; 링커 스크립트(kernel.ld)의 ENTRY(_start)가 이 주소를 가리킴

; === 커널 진입점 ===
; 부트로더의 'jmp 0x1000' 명령에 의해 이 위치로 제어권이 이양됨
_start:
    ; === 1단계: 세그먼트 레지스터 초기화 ===
    ; 32비트 보호 모드에서 세그먼트 레지스터를 올바르게 설정
    ; 부트로더에서 설정한 GDT를 사용하여 데이터 세그먼트 초기화
    mov ax, 0x10                      ; 데이터 세그먼트 셀렉터 (GDT 인덱스 2)
    mov ds, ax                        ; DS = 데이터 세그먼트
    mov es, ax                        ; ES = 추가 세그먼트  
    mov fs, ax                        ; FS = 추가 세그먼트
    mov gs, ax                        ; GS = 추가 세그먼트
    mov ss, ax                        ; SS = 스택 세그먼트
    
    ; === 2단계: 커널용 스택 설정 ===
    ; C 함수 호출과 지역 변수를 위한 스택 포인터 초기화
    ; 2단계 부트로더에서 설정한 스택(0x90000)과 같은 위치 사용
    mov esp, 0x90000              ; ESP = 0x90000 (576KB 위치)
                                   ; 스택은 높은 주소에서 낮은 주소로 자라므로
                                   ; 이 위치에서 아래쪽으로 스택이 확장됨
                                   ; 충분한 스택 공간 확보 (커널 함수 호출용)
    
    ; === 3단계: C 커널 메인 함수 호출 ===
    ; 어셈블리에서 C 언어로 제어권 이양
    ; 이후 모든 커널 로직은 C 언어로 구현됨 (더 복잡한 기능 구현 용이)
    call kernel_main               ; kernel.c의 kernel_main() 함수 호출
                                   ; C 호출 규약에 따라 ESP가 스택 포인터로 사용됨
                                   ; 함수 파라미터, 리턴 주소, 지역 변수 등이 스택에 저장됨
    
    ; === 4단계: 커널 종료 처리 ===
    ; kernel_main이 반환되면 (정상적으로는 반환되지 않아야 함) 시스템을 안전하게 정지
    ; 운영체제 커널은 일반적으로 무한 루프로 동작하므로 여기에 도달하면 비정상 상황
    cli                            ; Clear Interrupt Flag - 모든 인터럽트 비활성화
                                   ; 시스템 정지 중 외부 인터럽트로 인한 간섭 방지
                                   ; 타이머, 키보드, 마우스 등의 인터럽트가 비활성화됨
.loop:
    hlt                            ; Halt - CPU를 저전력 대기 상태로 전환
                                   ; CPU는 다음 인터럽트까지 실행을 중단함
                                   ; 인터럽트가 비활성화되어 있으므로 영구 정지 상태
    jmp .loop                      ; 무조건 점프로 무한 루프 구성
                                   ; HLT에서 깨어나더라도 (NMI 등) 다시 정지 상태로 이동
                                   ; 시스템의 완전한 정지를 보장
